#include "DoubaoTTS.h"#include "ArduinoJson.h"#include "utils.h"#include "driver/i2s.h"#include "freertos/task.h"#include "Arduino.h"#include <vector>#include "Settings.h"#include "AudioPlayer.h"constexpr uint8_t defaultHeader[] = {0x11, 0x10, 0x10, 0x00};DoubaoTTS::DoubaoTTS() {    _taskFinished = xSemaphoreCreateBinary();    begin();}void DoubaoTTS::eventCallback(const WStype_t type, uint8_t *payload, const size_t length) const {    switch (type) {        case WStype_PING:        case WStype_ERROR:        case WStype_CONNECTED:        case WStype_DISCONNECTED:        case WStype_TEXT:            break;        case WStype_BIN:            parseResponse(payload);            break;        default:            break;    }}String DoubaoTTS::buildFullClientRequest(const String &text) {    JsonDocument params;    const JsonObject app = params["app"].to<JsonObject>();    app["appid"] = Settings::getDoubaoAppId();    app["token"] = Settings::getDoubaoAccessToken();    app["cluster"] = "volcano_tts";    const JsonObject user = params["user"].to<JsonObject>();    user["uid"] = getChipId(nullptr);    const JsonObject audio = params["audio"].to<JsonObject>();    std::map<std::string, std::string> voiceMap = Settings::getVoiceMap();    audio["voice_type"] = voiceMap[Settings::getCurrentVoice().c_str()];    audio["encoding"] = "pcm";    audio["rate"] = 16000;    audio["speed_ratio"] = Settings::getCurrentSpeakSpeedRatio();    audio["volume_ratio"] = Settings::getCurrentSpeakVolumeRatio();    audio["pitch_ratio"] = 1.0;    const JsonObject request = params["request"].to<JsonObject>();    request["reqid"] = generateTaskId();    request["with_timestamp"] = 0;    request["text"] = text;    request["text_type"] = "plain";    request["operation"] = "submit";    String resStr;    serializeJson(params, resStr);    return resStr;}void DoubaoTTS::synth(const String &text, const bool disconnectAfter) {    if (text.isEmpty()) {        return;    }    log_d("text to speech synth: %s", text.c_str());    while (!isConnected()) {        loop();        vTaskDelay(1);    }    const String payloadStr = buildFullClientRequest(text);    uint8_t payload[payloadStr.length()];    for (int i = 0; i < payloadStr.length(); i++) {        payload[i] = static_cast<uint8_t>(payloadStr.charAt(i));    }    payload[payloadStr.length()] = '\0';    const uint32_t payloadSize = payloadStr.length();    std::vector<uint8_t> payloadLength = int2Array(payloadSize);    std::vector<uint8_t> clientRequest(defaultHeader, defaultHeader + sizeof(defaultHeader));    clientRequest.insert(clientRequest.end(), payloadLength.begin(), payloadLength.end());    clientRequest.insert(clientRequest.end(), payload, payload + sizeof(payload));    if (!sendBIN(clientRequest.data(), clientRequest.size())) {        log_e("text to speech synth failed: %s", text.c_str());        xSemaphoreGive(_taskFinished);        return;    }    while (xSemaphoreTake(_taskFinished, 0) == pdFALSE) {        loop();        vTaskDelay(1);    }    if (disconnectAfter) {        disconnect();    }}void DoubaoTTS::parseResponse(const uint8_t *response) const {    const uint8_t messageType = response[1] >> 4;    const uint8_t messageTypeSpecificFlags = response[1] & 0x0f;    const uint8_t *payload = response + 4;    switch (messageType) {        case 0b1011: {            // 0b1011 - Audio-only server response (ACK).            if (messageTypeSpecificFlags > 0) {                const auto sequenceNumber = parseInt32(payload);                const auto payloadSize = parseInt32(payload + 4);                payload += 8;                PlayAudioTask task{};                task.length = payloadSize;                task.data = static_cast<uint8_t *>(ps_malloc(payloadSize * sizeof(uint8_t)));                memcpy(task.data, payload, payloadSize);                AudioPlayer::publishTask(task);                if (sequenceNumber < 0) {                    xSemaphoreGive(_taskFinished);                }            }            break;        }        case 0b1111: {            // Error message from server (例如错误的消息类型，不支持的序列化方法等等)            const uint8_t errorCode = parseInt32(payload);            const uint8_t messageSize = parseInt32(payload + 4);            const unsigned char *errMessage = payload + 8;            log_e("Text speech synth failed, code: %d, reason: %s", errorCode, String(errMessage, messageSize).c_str());            xSemaphoreGive(_taskFinished);            break;        }        default:            break;    }}void DoubaoTTS::begin() {    setExtraHeaders(("Authorization: Bearer; " + Settings::getDoubaoAccessToken()).c_str());    beginSSL("openspeech.bytedance.com", 443, "/api/v1/tts/ws_binary");    onEvent([this](WStype_t type, uint8_t *payload, size_t length) {        this->eventCallback(type, payload, length);    });}