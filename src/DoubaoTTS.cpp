#include "DoubaoTTS.h"#include "ArduinoJson.h"#include "utils.h"#include "driver/i2s.h"#include "freertos/task.h"#include "Arduino.h"#include <vector>#include "Settings.h"#include "AudioPlayer.h"constexpr uint8_t defaultHeader[] = {0x11, 0x10, 0x10, 0x00};DoubaoTTS::DoubaoTTS(const String &appId, const String &token, const String &host, const int port, const String &url) {    _appId = appId;    _token = token;    _host = host;    _port = port;    _url = url;    _taskFinished = xSemaphoreCreateBinary();    begin();}void DoubaoTTS::eventCallback(const WStype_t type, uint8_t *payload, const size_t length) const {    switch (type) {        case WStype_PING:        case WStype_ERROR:        case WStype_CONNECTED:        case WStype_DISCONNECTED:        case WStype_TEXT:            break;        case WStype_BIN:            parseResponse(payload);            break;        default:            break;    }}String DoubaoTTS::buildFullClientRequest(const String &text) const {    JsonDocument params;    const JsonObject app = params["app"].to<JsonObject>();    app["appid"] = _appId;    app["token"] = _token;    app["cluster"] = "volcano_tts";    const JsonObject user = params["user"].to<JsonObject>();    user["uid"] = getChipId(nullptr);    const JsonObject audio = params["audio"].to<JsonObject>();    audio["voice_type"] = Settings::getVoiceType();    audio["encoding"] = "pcm";    audio["rate"] = 16000;    audio["speed_ratio"] = Settings::getSpeedRatio();    audio["volume_ratio"] = Settings::getVolumeRatio();    audio["pitch_ratio"] = 1.0;    audio["emotion"] = Settings::getEmotion();    const JsonObject request = params["request"].to<JsonObject>();    request["reqid"] = generateTaskId();    request["with_timestamp"] = 0;    request["text"] = text;    request["text_type"] = "plain";    request["operation"] = "submit";    String resStr;    serializeJson(params, resStr);    return resStr;}void DoubaoTTS::synth(const String &text) {    if (text.isEmpty()) {        return;    }    log_d("Text speech synth: %s", text.c_str());    const unsigned long startTime = millis();    while (!isConnected()) {        loop();        log_d("Waiting for tts websocket connection...");        vTaskDelay(1);    }    const String payloadStr = buildFullClientRequest(text);    uint8_t payload[payloadStr.length()];    for (int i = 0; i < payloadStr.length(); i++) {        payload[i] = static_cast<uint8_t>(payloadStr.charAt(i));    }    payload[payloadStr.length()] = '\0';    const uint32_t payloadSize = payloadStr.length();    std::vector<uint8_t> payloadLength = int2Array(payloadSize);    std::vector<uint8_t> clientRequest(defaultHeader, defaultHeader + sizeof(defaultHeader));    clientRequest.insert(clientRequest.end(), payloadLength.begin(), payloadLength.end());    clientRequest.insert(clientRequest.end(), payload, payload + sizeof(payload));    log_d("Ready to send text speech synth request: %d", clientRequest.size());    sendBIN(clientRequest.data(), clientRequest.size());    while (xSemaphoreTake(_taskFinished, 0) == pdFALSE) {        loop();        vTaskDelay(1);    }    log_d("Text speech synth cost %lu ms", millis() - startTime);}void DoubaoTTS::parseResponse(const uint8_t *response) const {    const uint8_t messageType = response[1] >> 4;    const uint8_t messageTypeSpecificFlags = response[1] & 0x0f;    const uint8_t *payload = response + 4;    switch (messageType) {        case 0b1011: {            // 0b1011 - Audio-only server response (ACK).            if (messageTypeSpecificFlags > 0) {                const auto sequenceNumber = parseInt32(payload);                const auto payloadSize = parseInt32(payload + 4);                payload += 8;                PlayAudioTask task{};                task.length = payloadSize;                task.data = static_cast<uint8_t *>(ps_malloc(payloadSize * sizeof(uint8_t)));                memcpy(task.data, payload, payloadSize);                AudioPlayer::publishTask(task);                if (sequenceNumber < 0) {                    xSemaphoreGive(_taskFinished);                }            }            break;        }        case 0b1111: {            // Error message from server (例如错误的消息类型，不支持的序列化方法等等)            const uint8_t errorCode = parseInt32(payload);            const uint8_t messageSize = parseInt32(payload + 4);            const unsigned char *errMessage = payload + 8;            log_e("Text speech synth failed, code: %d, reason: %s", errorCode, String(errMessage, messageSize).c_str());            xSemaphoreGive(_taskFinished);            break;        }        default:            break;    }}void DoubaoTTS::begin() {    setExtraHeaders(("Authorization: Bearer; " + _token).c_str());    beginSSL(_host, _port, _url);    onEvent([this](WStype_t type, uint8_t *payload, size_t length) {        this->eventCallback(type, payload, length);    });}