#include "DoubaoTTS.h"#include "utils.h"#include "driver/i2s.h"#include "freertos/task.h"#include "Arduino.h"#include "PsramJson.h"#include <vector>#include "Settings.h"#include "LvglDisplay.h"constexpr uint8_t defaultHeader[] = {0x11, 0x10, 0x10, 0x00};DoubaoTTS::DoubaoTTS(i2s_port_t i2sNumber, uint32_t sampleRate,                     const String &appId,                     const String &token, const String &host, int port,                     const String &url, int i2sDout, int i2sBclk, int i2sLrc) {    _i2sNumber = i2sNumber;    _appId = appId;    _token = token;    _host = host;    _port = port;    _url = url;    _sampleRate = sampleRate;    _i2sDout = i2sDout;    _i2sBclk = i2sBclk;    _i2sLrc = i2sLrc;    _taskFinished = xSemaphoreCreateBinary();    setupMax98357();    begin();}void DoubaoTTS::eventCallback(const WStype_t type, uint8_t *payload, const size_t length) {    switch (type) {        case WStype_PING:        case WStype_ERROR:        case WStype_CONNECTED:        case WStype_DISCONNECTED:        case WStype_TEXT:            break;        case WStype_BIN:            parseResponse(payload);            break;        default:            break;    }}String DoubaoTTS::buildFullClientRequest(const String &text) const {    JsonDocument params(&spiRamAllocator);    const JsonObject app = params["app"].to<JsonObject>();    app["appid"] = _appId;    app["token"] = _token;    app["cluster"] = "volcano_tts";    const JsonObject user = params["user"].to<JsonObject>();    user["uid"] = getChipId(nullptr);    const JsonObject audio = params["audio"].to<JsonObject>();    audio["voice_type"] = Settings::getVoiceType();    audio["encoding"] = "pcm";    audio["rate"] = _sampleRate;    audio["speed_ratio"] = Settings::getSpeedRatio();    audio["volume_ratio"] = Settings::getVolumeRatio();    audio["pitch_ratio"] = 1.0;    audio["emotion"] = Settings::getEmotion();    const JsonObject request = params["request"].to<JsonObject>();    request["reqid"] = generateTaskId();    request["with_timestamp"] = 0;    request["text"] = text;    request["text_type"] = "plain";    request["operation"] = "submit";    String resStr;    serializeJson(params, resStr);    return resStr;}void DoubaoTTS::synth(const String &text) {    if (text.isEmpty()) {        return;    }    Serial.printf("语音合成: %s\n", text.c_str());    while (!isConnected()) {        loop();        vTaskDelay(1);    }    const String payloadStr = buildFullClientRequest(text);    uint8_t payload[payloadStr.length()];    for (int i = 0; i < payloadStr.length(); i++) {        payload[i] = static_cast<uint8_t>(payloadStr.charAt(i));    }    payload[payloadStr.length()] = '\0';    const uint32_t payloadSize = payloadStr.length();    std::vector<uint8_t> payloadLength = int2Array(payloadSize);    std::vector<uint8_t> clientRequest(defaultHeader, defaultHeader + sizeof(defaultHeader));    clientRequest.insert(clientRequest.end(), payloadLength.begin(), payloadLength.end());    clientRequest.insert(clientRequest.end(), payload, payload + sizeof(payload));    sendBIN(clientRequest.data(), clientRequest.size());    while (xSemaphoreTake(_taskFinished, 0) == pdFALSE) {        loop();        vTaskDelay(1);    }}void DoubaoTTS::setupMax98357() const {    const i2s_config_t max98357_i2s_config = {            .mode = static_cast<i2s_mode_t>(I2S_MODE_MASTER | I2S_MODE_TX),            .sample_rate = _sampleRate,            .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,            .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,            .communication_format = I2S_COMM_FORMAT_STAND_I2S,            .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,            .dma_buf_count = 8,            .dma_buf_len = 1024,            .tx_desc_auto_clear = true    };    const i2s_pin_config_t max98357_gpio_config = {            .bck_io_num = _i2sBclk,            .ws_io_num = _i2sLrc,            .data_out_num = _i2sDout,            .data_in_num = -1    };    i2s_driver_install(_i2sNumber, &max98357_i2s_config, 0, nullptr);    i2s_set_pin(_i2sNumber, &max98357_gpio_config);    i2s_zero_dma_buffer(_i2sNumber);}void DoubaoTTS::begin() {    setExtraHeaders(("Authorization: Bearer; " + _token).c_str());    beginSSL(_host, _port, _url);    onEvent([this](WStype_t type, uint8_t *payload, size_t length) {        this->eventCallback(type, payload, length);    });}void DoubaoTTS::parseResponse(const uint8_t *response) const {    const uint8_t messageType = response[1] >> 4;    const uint8_t messageTypeSpecificFlags = response[1] & 0x0f;    const uint8_t *payload = response + 4;    switch (messageType) {        case 0b1011: {            // 0b1011 - Audio-only server response (ACK).            if (messageTypeSpecificFlags > 0) {                const auto sequenceNumber = parseInt32(payload);                const auto payloadSize = parseInt32(payload + 4);                payload += 8;                size_t written_size;                i2s_write(_i2sNumber, payload, payloadSize, &written_size, portMAX_DELAY);                if (sequenceNumber < 0) {                    xSemaphoreGive(_taskFinished);                }            }            break;        }        case 0b1111: {            // Error message from server (例如错误的消息类型，不支持的序列化方法等等)            const uint8_t errorCode = parseInt32(payload);            const uint8_t messageSize = parseInt32(payload + 4);            const unsigned char *errMessage = payload + 8;            Serial.printf("语音合成失败: %d\n原因: %s\n", errorCode, String(errMessage, messageSize).c_str());            xSemaphoreGive(_taskFinished);            break;        }        default:            break;    }}